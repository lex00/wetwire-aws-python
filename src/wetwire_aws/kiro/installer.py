"""Kiro CLI configuration installer.

This module handles auto-installation of Kiro CLI configurations:
- Agent config (~/.kiro/agents/wetwire-runner.json)
- MCP config (.kiro/mcp.json in project directory)
"""

from __future__ import annotations

import json
import shutil
import subprocess
import sys
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any

# Embedded agent configuration
# Note: mcpServers will be populated dynamically with the correct path
AGENT_CONFIG: dict[str, Any] = {
    "name": "wetwire-runner",
    "description": "Infrastructure code generator using wetwire-aws Python syntax",
    "model": "claude-sonnet-4",
    "tools": ["*"],
    "mcpServers": {},  # Populated in install_agent_config
    "prompt": """You are an infrastructure design assistant specialized in AWS CloudFormation using wetwire-aws Python syntax.

When starting a new conversation, greet the user and ask what AWS infrastructure they'd like to build. Be helpful and guide them through the design process.

## Package Structure (CRITICAL - READ CAREFULLY)

Step 1: ALWAYS use wetwire_init MCP tool first to create the package
Step 2: Create NEW .py files for resources (storage.py, compute.py, etc.)
Step 3: NEVER EVER touch __init__.py

```
my_package/
├── __init__.py      # AUTO-GENERATED - NEVER MODIFY THIS FILE
├── storage.py       # Create this file for S3, DynamoDB
├── compute.py       # Create this file for Lambda, EC2
└── security.py      # Create this file for IAM
```

FORBIDDEN ACTIONS:
- DO NOT edit __init__.py under any circumstances
- DO NOT add imports to __init__.py
- DO NOT add classes to __init__.py
- DO NOT modify __init__.py in any way

The __init__.py is generated by wetwire_init with the correct setup_resources() call. Any modification will break the build.

## wetwire-aws Python Syntax Principles

1. RESOURCE DECLARATION - Resources are Python classes inheriting from generated types:
   ```python
   from . import *  # noqa: F403 - imports s3, lambda_, iam, etc.

   class MyBucket(s3.Bucket):
       bucket_name = "my-data"
   ```

2. DIRECT REFERENCES - Reference other resources by class name:
   ```python
   class MyFunction(lambda_.Function):
       role = MyRole.Arn  # GetAtt via attribute access
       environment = MyEnv
   ```

3. NESTED TYPES - Extract nested configs to separate classes:
   ```python
   class MyEnv(lambda_.Environment):
       variables = MyVariables
   ```

4. TYPE-SAFE CONSTANTS - Use typed enums instead of strings:
   ```python
   runtime = lambda_.Runtime.PYTHON3_12  # Not "python3.12"
   ```

## Key Lint Rules (WAW001-WAW020)
- WAW001-004: Use typed constants (parameters, pseudo-params, enums, intrinsics)
- WAW006: No-parens references (use MyRole.Arn not MyRole().Arn)
- WAW013: Use wrapper classes, not inline constructors
- WAW019-020: Avoid explicit Ref() and GetAtt() - use direct references

## Design Workflow

EXAMPLE - Creating an S3 bucket:

1. Use wetwire_init to create package:
   wetwire_init(path=".", module_name="my_bucket")

2. Create storage.py (NOT __init__.py) with content:
   ```python
   from . import *  # noqa: F403

   class DataBucket(s3.Bucket):
       bucket_name = "my-data-bucket"
   ```

3. Run wetwire_lint to check:
   wetwire_lint(path="./my_bucket")

4. Run wetwire_build to generate template:
   wetwire_build(path="./my_bucket")

IMPORTANT:
- Only call wetwire_init ONCE per package
- NEVER delete directories or start over - always fix errors in place
- NEVER modify __init__.py - only create/edit other .py files
- If lint or build fails, read the error, fix the code, and retry
- Keep iterating on the SAME package until it works""",
}


def get_agent_config_path() -> Path:
    """Get the path to the agent config file."""
    return Path.home() / ".kiro" / "agents" / "wetwire-runner.json"


def get_mcp_config_path(project_dir: Path | None = None) -> Path:
    """Get the path to the MCP config file."""
    if project_dir is None:
        project_dir = Path.cwd()
    return project_dir / ".kiro" / "mcp.json"


def check_kiro_installed() -> bool:
    """Check if Kiro CLI is installed and available."""
    return shutil.which("kiro-cli") is not None


def _get_mcp_server_path() -> str | None:
    """Find the absolute path to wetwire-aws-mcp command.

    Returns:
        Absolute path to the command, or None if not found.
    """
    # First check if it's in PATH
    mcp_path = shutil.which("wetwire-aws-mcp")
    if mcp_path:
        return mcp_path

    # Check common locations where uv/pip might install scripts
    try:
        # Try to find it via the current Python environment
        result = subprocess.run(
            [sys.executable, "-c", "import shutil; print(shutil.which('wetwire-aws-mcp') or '')"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    return None


def install_agent_config(force: bool = False) -> bool:
    """Install the wetwire-runner agent config.

    Args:
        force: Overwrite existing config if True.

    Returns:
        True if config was installed, False if skipped.
    """
    config_path = get_agent_config_path()

    if config_path.exists() and not force:
        return False

    # Create a copy of the config to populate mcpServers
    config = AGENT_CONFIG.copy()

    # Find the MCP server path and add to agent config
    mcp_server_path = _get_mcp_server_path()
    if mcp_server_path:
        config["mcpServers"] = {
            "wetwire-aws-mcp": {
                "command": mcp_server_path,
                "args": [],
            }
        }
    else:
        # Fallback to uv run
        config["mcpServers"] = {
            "wetwire-aws-mcp": {
                "command": "uv",
                "args": ["run", "wetwire-aws-mcp"],
            }
        }

    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(config, indent=2))
    return True


def install_mcp_config(project_dir: Path | None = None, force: bool = False) -> bool:
    """Install the MCP server config in project directory.

    Args:
        project_dir: Project directory. Defaults to current directory.
        force: Overwrite existing config if True.

    Returns:
        True if config was installed, False if skipped.
    """
    config_path = get_mcp_config_path(project_dir)

    # Load existing config or create new one
    if config_path.exists():
        if not force:
            # Check if wetwire-aws-mcp is already configured
            existing = json.loads(config_path.read_text())
            if "wetwire-aws-mcp" in existing.get("mcpServers", {}):
                return False
            # Merge with existing
            mcp_config = existing
        else:
            mcp_config = {"mcpServers": {}}
    else:
        mcp_config = {"mcpServers": {}}

    # Try to find absolute path to wetwire-aws-mcp
    mcp_server_path = _get_mcp_server_path()

    if mcp_server_path:
        # Use absolute path to the installed command
        mcp_config["mcpServers"]["wetwire-aws-mcp"] = {
            "command": mcp_server_path,
        }
    else:
        # Fall back to uv run (works if wetwire-aws is installed in project)
        mcp_config["mcpServers"]["wetwire-aws-mcp"] = {
            "command": "uv",
            "args": ["run", "wetwire-aws-mcp"],
        }

    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(json.dumps(mcp_config, indent=2))
    return True


def install_kiro_configs(
    project_dir: Path | None = None, force: bool = False, verbose: bool = False
) -> dict[str, bool]:
    """Install all Kiro configurations.

    Args:
        project_dir: Project directory for MCP config. Defaults to cwd.
        force: Overwrite existing configs if True.
        verbose: Print status messages.

    Returns:
        Dict with 'agent' and 'mcp' keys indicating what was installed.
    """
    results = {
        "agent": install_agent_config(force=force),
        "mcp": install_mcp_config(project_dir=project_dir, force=force),
    }

    if verbose:
        if results["agent"]:
            print(f"Installed agent config: {get_agent_config_path()}", file=sys.stderr)
        if results["mcp"]:
            print(
                f"Installed MCP config: {get_mcp_config_path(project_dir)}",
                file=sys.stderr,
            )

    return results


def launch_kiro(prompt: str | None = None, project_dir: Path | None = None) -> int:
    """Launch Kiro CLI with the wetwire-runner agent.

    Args:
        prompt: Optional initial prompt for the conversation.
        project_dir: Project directory. Defaults to current directory.

    Returns:
        Exit code from kiro-cli.
    """
    if not check_kiro_installed():
        print(
            "Error: Kiro CLI not found. Install from https://kiro.dev/docs/cli/",
            file=sys.stderr,
        )
        return 1

    # Force reinstall configs every time to ensure latest agent prompt is used
    install_kiro_configs(project_dir=project_dir, force=True, verbose=True)

    # Build command
    cmd = ["kiro-cli", "chat", "--agent", "wetwire-runner", "--trust-all-tools"]
    # Always send an initial message to start the conversation
    # If user provided a prompt, use it; otherwise ask agent to introduce itself
    initial_message = prompt if prompt else "Hello! I'm ready to design some AWS infrastructure."
    cmd.append(initial_message)

    # Launch Kiro
    try:
        result = subprocess.run(cmd, cwd=project_dir)
        return result.returncode
    except FileNotFoundError:
        print("Error: Failed to launch kiro-cli.", file=sys.stderr)
        return 1


def _run_with_script(
    cmd: list[str],
    cwd: Path,
    timeout: int,
) -> tuple[int, str, str]:
    """Run a command with a pseudo-terminal using the 'script' utility.

    kiro-cli requires a TTY even with --no-interactive, so we use
    the 'script' command to provide one. This is more robust than
    using Python's pty module directly.

    Args:
        cmd: Command and arguments to run.
        cwd: Working directory.
        timeout: Timeout in seconds.

    Returns:
        Tuple of (exit_code, stdout, stderr).
    """
    import platform
    import tempfile

    # Create a temp file for output
    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
        output_file = f.name

    try:
        # Build script command - differs between macOS and Linux
        if platform.system() == "Darwin":
            # macOS: script -q output_file command args...
            script_cmd = ["script", "-q", output_file] + cmd
        else:
            # Linux: script -q -c "command args..." output_file
            script_cmd = ["script", "-q", "-c", " ".join(cmd), output_file]

        # Don't capture output - let script handle it via the output file
        # stdin from /dev/null to prevent blocking on input
        with open("/dev/null", "r") as devnull:
            result = subprocess.run(
                script_cmd,
                cwd=cwd,
                stdin=devnull,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                text=True,
                timeout=timeout,
            )

        # Read output from file
        try:
            with open(output_file) as f:
                stdout = f.read()
        except FileNotFoundError:
            stdout = ""

        return result.returncode, stdout, result.stderr or ""

    except subprocess.TimeoutExpired:
        return -1, "", f"Timeout after {timeout} seconds"
    finally:
        # Clean up output file
        try:
            Path(output_file).unlink()
        except FileNotFoundError:
            pass


def run_kiro_scenario(
    prompt: str,
    project_dir: Path | None = None,
    timeout: int = 300,
    auto_exit: bool = True,
) -> dict[str, Any]:
    """Run a Kiro CLI scenario non-interactively for testing.

    This function runs kiro-cli with a prompt and captures output,
    suitable for automated testing and CI pipelines.

    Note: kiro-cli requires a TTY even with --no-interactive, so this
    function uses a pseudo-terminal (PTY) wrapper on Unix systems.

    Args:
        prompt: The infrastructure prompt to send to Kiro.
        project_dir: Project directory. Defaults to temp directory.
        timeout: Maximum time in seconds to wait (default: 300).
        auto_exit: If True, append instruction to exit after completion.

    Returns:
        Dict with keys:
            - success: bool - Whether the scenario completed successfully
            - exit_code: int - Process exit code
            - stdout: str - Captured stdout
            - stderr: str - Captured stderr
            - package_path: str | None - Path to created package if any
            - template_valid: bool - Whether build produced valid template
    """
    import tempfile

    if not check_kiro_installed():
        return {
            "success": False,
            "exit_code": 1,
            "stdout": "",
            "stderr": "Kiro CLI not found",
            "package_path": None,
            "template_valid": False,
        }

    # Use temp directory if not specified
    if project_dir is None:
        temp_dir = tempfile.mkdtemp(prefix="kiro_test_")
        project_dir = Path(temp_dir)
    else:
        project_dir = Path(project_dir)
        project_dir.mkdir(parents=True, exist_ok=True)

    # Ensure configs are installed
    install_kiro_configs(project_dir=project_dir, verbose=False)

    # Build the full prompt with auto-exit instruction
    full_prompt = prompt
    if auto_exit:
        full_prompt = (
            f"{prompt}\n\n"
            "After successfully creating the package and running lint and build, "
            "output 'SCENARIO_COMPLETE' and exit."
        )

    # Build command for non-interactive execution
    # kiro-cli chat [OPTIONS] [INPUT] - input is positional
    cmd = [
        "kiro-cli",
        "chat",
        "--agent", "wetwire-runner",
        "--no-interactive",
        "--trust-all-tools",  # Auto-approve tool usage for non-interactive mode
        full_prompt,
    ]

    # Run kiro-cli with PTY wrapper (required even with --no-interactive)
    try:
        exit_code, stdout, stderr = _run_with_script(cmd, project_dir, timeout)
    except FileNotFoundError:
        return {
            "success": False,
            "exit_code": 1,
            "stdout": "",
            "stderr": "Failed to launch kiro-cli",
            "package_path": None,
            "template_valid": False,
        }

    # Handle timeout
    if exit_code == -1 and "Timeout" in stderr:
        return {
            "success": False,
            "exit_code": -1,
            "stdout": stdout,
            "stderr": stderr,
            "package_path": None,
            "template_valid": False,
        }

    # Find created package (look for directories with __init__.py)
    package_path = None
    for item in project_dir.iterdir():
        if item.is_dir() and (item / "__init__.py").exists():
            # Skip .kiro directory
            if item.name != ".kiro":
                package_path = str(item)
                break

    # Check if template is valid by running build
    template_valid = False
    if package_path:
        try:
            build_result = subprocess.run(
                ["wetwire-aws", "build", package_path],
                capture_output=True,
                text=True,
                timeout=30,
            )
            template_valid = build_result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass

    return {
        "success": exit_code == 0 and template_valid,
        "exit_code": exit_code,
        "stdout": stdout,
        "stderr": stderr,
        "package_path": package_path,
        "template_valid": template_valid,
    }

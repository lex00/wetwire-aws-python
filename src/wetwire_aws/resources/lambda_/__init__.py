"""
AWS LAMBDA_ CloudFormation resources.

Generated:
  Source: CloudFormation Spec 2026.01.02
  Generator: 1.0.0
  Date: 2026-01-07T05:29:22Z

DO NOT EDIT - This file is generated by wetwire-aws codegen.
To regenerate: python -m wetwire_aws.codegen.generate
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, ClassVar

from wetwire_aws.base import (
    CloudFormationResource,
    PropertyType,
    PropertyTypeDescriptor,
    Tag,
)
from wetwire_aws.typing import DslValue


# Constants
# ============================================================


class ApplicationLogLevel:
    TRACE = "TRACE"
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARN = "WARN"
    ERROR = "ERROR"
    FATAL = "FATAL"


class Architecture:
    X86_64 = "x86_64"
    ARM64 = "arm64"


class CapacityProviderPredefinedMetricType:
    LAMBDACAPACITYPROVIDERAVERAGECPUUTILIZATION = (
        "LambdaCapacityProviderAverageCPUUtilization"
    )


class CapacityProviderScalingMode:
    AUTO = "Auto"
    MANUAL = "Manual"


class CapacityProviderState:
    PENDING = "Pending"
    ACTIVE = "Active"
    FAILED = "Failed"
    DELETING = "Deleting"


class CodeSigningPolicy:
    WARN = "Warn"
    ENFORCE = "Enforce"


class EndPointType:
    KAFKA_BOOTSTRAP_SERVERS = "KAFKA_BOOTSTRAP_SERVERS"


class EventSourceMappingMetric:
    EVENTCOUNT = "EventCount"


class EventSourcePosition:
    TRIM_HORIZON = "TRIM_HORIZON"
    LATEST = "LATEST"
    AT_TIMESTAMP = "AT_TIMESTAMP"


class EventType:
    EXECUTIONSTARTED = "ExecutionStarted"
    EXECUTIONSUCCEEDED = "ExecutionSucceeded"
    EXECUTIONFAILED = "ExecutionFailed"
    EXECUTIONTIMEDOUT = "ExecutionTimedOut"
    EXECUTIONSTOPPED = "ExecutionStopped"
    CONTEXTSTARTED = "ContextStarted"
    CONTEXTSUCCEEDED = "ContextSucceeded"
    CONTEXTFAILED = "ContextFailed"
    WAITSTARTED = "WaitStarted"
    WAITSUCCEEDED = "WaitSucceeded"
    WAITCANCELLED = "WaitCancelled"
    STEPSTARTED = "StepStarted"
    STEPSUCCEEDED = "StepSucceeded"
    STEPFAILED = "StepFailed"
    CHAINEDINVOKESTARTED = "ChainedInvokeStarted"
    CHAINEDINVOKESUCCEEDED = "ChainedInvokeSucceeded"
    CHAINEDINVOKEFAILED = "ChainedInvokeFailed"
    CHAINEDINVOKETIMEDOUT = "ChainedInvokeTimedOut"
    CHAINEDINVOKESTOPPED = "ChainedInvokeStopped"
    CALLBACKSTARTED = "CallbackStarted"
    CALLBACKSUCCEEDED = "CallbackSucceeded"
    CALLBACKFAILED = "CallbackFailed"
    CALLBACKTIMEDOUT = "CallbackTimedOut"
    INVOCATIONCOMPLETED = "InvocationCompleted"


class ExecutionStatus:
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"
    STOPPED = "STOPPED"


class FullDocument:
    UPDATELOOKUP = "UpdateLookup"
    DEFAULT = "Default"


class FunctionResponseType:
    REPORTBATCHITEMFAILURES = "ReportBatchItemFailures"


class FunctionUrlAuthType:
    NONE = "NONE"
    AWS_IAM = "AWS_IAM"


class FunctionVersion:
    ALL = "ALL"


class FunctionVersionLatestPublished:
    LATEST_PUBLISHED = "LATEST_PUBLISHED"


class InvocationType:
    EVENT = "Event"
    REQUESTRESPONSE = "RequestResponse"
    DRYRUN = "DryRun"


class InvokeMode:
    BUFFERED = "BUFFERED"
    RESPONSE_STREAM = "RESPONSE_STREAM"


class KafkaSchemaRegistryAuthType:
    BASIC_AUTH = "BASIC_AUTH"
    CLIENT_CERTIFICATE_TLS_AUTH = "CLIENT_CERTIFICATE_TLS_AUTH"
    SERVER_ROOT_CA_CERTIFICATE = "SERVER_ROOT_CA_CERTIFICATE"


class KafkaSchemaValidationAttribute:
    KEY = "KEY"
    VALUE = "VALUE"


class LastUpdateStatus:
    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    INPROGRESS = "InProgress"


class LastUpdateStatusReasonCode:
    ENILIMITEXCEEDED = "EniLimitExceeded"
    INSUFFICIENTROLEPERMISSIONS = "InsufficientRolePermissions"
    INVALIDCONFIGURATION = "InvalidConfiguration"
    INTERNALERROR = "InternalError"
    SUBNETOUTOFIPADDRESSES = "SubnetOutOfIPAddresses"
    INVALIDSUBNET = "InvalidSubnet"
    INVALIDSECURITYGROUP = "InvalidSecurityGroup"
    IMAGEDELETED = "ImageDeleted"
    IMAGEACCESSDENIED = "ImageAccessDenied"
    INVALIDIMAGE = "InvalidImage"
    KMSKEYACCESSDENIED = "KMSKeyAccessDenied"
    KMSKEYNOTFOUND = "KMSKeyNotFound"
    INVALIDSTATEKMSKEY = "InvalidStateKMSKey"
    DISABLEDKMSKEY = "DisabledKMSKey"
    EFSIOERROR = "EFSIOError"
    EFSMOUNTCONNECTIVITYERROR = "EFSMountConnectivityError"
    EFSMOUNTFAILURE = "EFSMountFailure"
    EFSMOUNTTIMEOUT = "EFSMountTimeout"
    INVALIDRUNTIME = "InvalidRuntime"
    INVALIDZIPFILEEXCEPTION = "InvalidZipFileException"
    FUNCTIONERROR = "FunctionError"
    VCPULIMITEXCEEDED = "VcpuLimitExceeded"
    CAPACITYPROVIDERSCALINGLIMITEXCEEDED = "CapacityProviderScalingLimitExceeded"
    INSUFFICIENTCAPACITY = "InsufficientCapacity"
    EC2REQUESTLIMITEXCEEDED = "EC2RequestLimitExceeded"
    FUNCTIONERROR_INITTIMEOUT = "FunctionError.InitTimeout"
    FUNCTIONERROR_RUNTIMEINITERROR = "FunctionError.RuntimeInitError"
    FUNCTIONERROR_EXTENSIONINITERROR = "FunctionError.ExtensionInitError"
    FUNCTIONERROR_INVALIDENTRYPOINT = "FunctionError.InvalidEntryPoint"
    FUNCTIONERROR_INVALIDWORKINGDIRECTORY = "FunctionError.InvalidWorkingDirectory"
    FUNCTIONERROR_PERMISSIONDENIED = "FunctionError.PermissionDenied"
    FUNCTIONERROR_TOOMANYEXTENSIONS = "FunctionError.TooManyExtensions"
    FUNCTIONERROR_INITRESOURCEEXHAUSTED = "FunctionError.InitResourceExhausted"
    DISALLOWEDBYVPCENCRYPTIONCONTROL = "DisallowedByVpcEncryptionControl"


class LogFormat:
    JSON = "JSON"
    TEXT = "Text"


class LogType:
    NONE = "None"
    TAIL = "Tail"


class OperationAction:
    START = "START"
    SUCCEED = "SUCCEED"
    FAIL = "FAIL"
    RETRY = "RETRY"
    CANCEL = "CANCEL"


class OperationStatus:
    STARTED = "STARTED"
    PENDING = "PENDING"
    READY = "READY"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"
    TIMED_OUT = "TIMED_OUT"
    STOPPED = "STOPPED"


class OperationType:
    EXECUTION = "EXECUTION"
    CONTEXT = "CONTEXT"
    STEP = "STEP"
    WAIT = "WAIT"
    CALLBACK = "CALLBACK"
    CHAINED_INVOKE = "CHAINED_INVOKE"


class PackageType:
    ZIP = "Zip"
    IMAGE = "Image"


class ProvisionedConcurrencyStatusEnum:
    IN_PROGRESS = "IN_PROGRESS"
    READY = "READY"
    FAILED = "FAILED"


class RecursiveLoop:
    ALLOW = "Allow"
    TERMINATE = "Terminate"


class ResponseStreamingInvocationType:
    REQUESTRESPONSE = "RequestResponse"
    DRYRUN = "DryRun"


class Runtime:
    NODEJS = "nodejs"
    NODEJS4_3 = "nodejs4.3"
    NODEJS6_10 = "nodejs6.10"
    NODEJS8_10 = "nodejs8.10"
    NODEJS10_X = "nodejs10.x"
    NODEJS12_X = "nodejs12.x"
    NODEJS14_X = "nodejs14.x"
    NODEJS16_X = "nodejs16.x"
    JAVA8 = "java8"
    JAVA8_AL2 = "java8.al2"
    JAVA11 = "java11"
    PYTHON2_7 = "python2.7"
    PYTHON3_6 = "python3.6"
    PYTHON3_7 = "python3.7"
    PYTHON3_8 = "python3.8"
    PYTHON3_9 = "python3.9"
    DOTNETCORE1_0 = "dotnetcore1.0"
    DOTNETCORE2_0 = "dotnetcore2.0"
    DOTNETCORE2_1 = "dotnetcore2.1"
    DOTNETCORE3_1 = "dotnetcore3.1"
    DOTNET6 = "dotnet6"
    DOTNET8 = "dotnet8"
    NODEJS4_3_EDGE = "nodejs4.3-edge"
    GO1_X = "go1.x"
    RUBY2_5 = "ruby2.5"
    RUBY2_7 = "ruby2.7"
    PROVIDED = "provided"
    PROVIDED_AL2 = "provided.al2"
    NODEJS18_X = "nodejs18.x"
    PYTHON3_10 = "python3.10"
    JAVA17 = "java17"
    RUBY3_2 = "ruby3.2"
    RUBY3_3 = "ruby3.3"
    RUBY3_4 = "ruby3.4"
    PYTHON3_11 = "python3.11"
    NODEJS20_X = "nodejs20.x"
    PROVIDED_AL2023 = "provided.al2023"
    PYTHON3_12 = "python3.12"
    JAVA21 = "java21"
    PYTHON3_13 = "python3.13"
    NODEJS22_X = "nodejs22.x"
    NODEJS24_X = "nodejs24.x"
    PYTHON3_14 = "python3.14"
    JAVA25 = "java25"
    DOTNET10 = "dotnet10"


class SchemaRegistryEventRecordFormat:
    JSON = "JSON"
    SOURCE = "SOURCE"


class SnapStartApplyOn:
    PUBLISHEDVERSIONS = "PublishedVersions"
    NONE = "None"


class SnapStartOptimizationStatus:
    ON = "On"
    OFF = "Off"


class SourceAccessType:
    BASIC_AUTH = "BASIC_AUTH"
    VPC_SUBNET = "VPC_SUBNET"
    VPC_SECURITY_GROUP = "VPC_SECURITY_GROUP"
    SASL_SCRAM_512_AUTH = "SASL_SCRAM_512_AUTH"
    SASL_SCRAM_256_AUTH = "SASL_SCRAM_256_AUTH"
    VIRTUAL_HOST = "VIRTUAL_HOST"
    CLIENT_CERTIFICATE_TLS_AUTH = "CLIENT_CERTIFICATE_TLS_AUTH"
    SERVER_ROOT_CA_CERTIFICATE = "SERVER_ROOT_CA_CERTIFICATE"


class State:
    PENDING = "Pending"
    ACTIVE = "Active"
    INACTIVE = "Inactive"
    FAILED = "Failed"
    DEACTIVATING = "Deactivating"
    DEACTIVATED = "Deactivated"
    ACTIVENONINVOCABLE = "ActiveNonInvocable"
    DELETING = "Deleting"


class StateReasonCode:
    IDLE = "Idle"
    CREATING = "Creating"
    RESTORING = "Restoring"
    ENILIMITEXCEEDED = "EniLimitExceeded"
    INSUFFICIENTROLEPERMISSIONS = "InsufficientRolePermissions"
    INVALIDCONFIGURATION = "InvalidConfiguration"
    INTERNALERROR = "InternalError"
    SUBNETOUTOFIPADDRESSES = "SubnetOutOfIPAddresses"
    INVALIDSUBNET = "InvalidSubnet"
    INVALIDSECURITYGROUP = "InvalidSecurityGroup"
    IMAGEDELETED = "ImageDeleted"
    IMAGEACCESSDENIED = "ImageAccessDenied"
    INVALIDIMAGE = "InvalidImage"
    KMSKEYACCESSDENIED = "KMSKeyAccessDenied"
    KMSKEYNOTFOUND = "KMSKeyNotFound"
    INVALIDSTATEKMSKEY = "InvalidStateKMSKey"
    DISABLEDKMSKEY = "DisabledKMSKey"
    EFSIOERROR = "EFSIOError"
    EFSMOUNTCONNECTIVITYERROR = "EFSMountConnectivityError"
    EFSMOUNTFAILURE = "EFSMountFailure"
    EFSMOUNTTIMEOUT = "EFSMountTimeout"
    INVALIDRUNTIME = "InvalidRuntime"
    INVALIDZIPFILEEXCEPTION = "InvalidZipFileException"
    FUNCTIONERROR = "FunctionError"
    DRAININGDURABLEEXECUTIONS = "DrainingDurableExecutions"
    VCPULIMITEXCEEDED = "VcpuLimitExceeded"
    CAPACITYPROVIDERSCALINGLIMITEXCEEDED = "CapacityProviderScalingLimitExceeded"
    INSUFFICIENTCAPACITY = "InsufficientCapacity"
    EC2REQUESTLIMITEXCEEDED = "EC2RequestLimitExceeded"
    FUNCTIONERROR_INITTIMEOUT = "FunctionError.InitTimeout"
    FUNCTIONERROR_RUNTIMEINITERROR = "FunctionError.RuntimeInitError"
    FUNCTIONERROR_EXTENSIONINITERROR = "FunctionError.ExtensionInitError"
    FUNCTIONERROR_INVALIDENTRYPOINT = "FunctionError.InvalidEntryPoint"
    FUNCTIONERROR_INVALIDWORKINGDIRECTORY = "FunctionError.InvalidWorkingDirectory"
    FUNCTIONERROR_PERMISSIONDENIED = "FunctionError.PermissionDenied"
    FUNCTIONERROR_TOOMANYEXTENSIONS = "FunctionError.TooManyExtensions"
    FUNCTIONERROR_INITRESOURCEEXHAUSTED = "FunctionError.InitResourceExhausted"
    DISALLOWEDBYVPCENCRYPTIONCONTROL = "DisallowedByVpcEncryptionControl"


class SystemLogLevel:
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARN = "WARN"


class TenantIsolationMode:
    PER_TENANT = "PER_TENANT"


class ThrottleReason:
    CONCURRENTINVOCATIONLIMITEXCEEDED = "ConcurrentInvocationLimitExceeded"
    FUNCTIONINVOCATIONRATELIMITEXCEEDED = "FunctionInvocationRateLimitExceeded"
    RESERVEDFUNCTIONCONCURRENTINVOCATIONLIMITEXCEEDED = (
        "ReservedFunctionConcurrentInvocationLimitExceeded"
    )
    RESERVEDFUNCTIONINVOCATIONRATELIMITEXCEEDED = (
        "ReservedFunctionInvocationRateLimitExceeded"
    )
    CALLERRATELIMITEXCEEDED = "CallerRateLimitExceeded"
    CONCURRENTSNAPSHOTCREATELIMITEXCEEDED = "ConcurrentSnapshotCreateLimitExceeded"


class TracingMode:
    ACTIVE = "Active"
    PASSTHROUGH = "PassThrough"


class UpdateRuntimeOn:
    AUTO = "Auto"
    MANUAL = "Manual"
    FUNCTIONUPDATE = "FunctionUpdate"


# PropertyType submodules
from . import Alias as _Alias
from . import CapacityProvider as _CapacityProvider
from . import CodeSigningConfig as _CodeSigningConfig
from . import EventInvokeConfig as _EventInvokeConfig
from . import EventSourceMapping as _EventSourceMapping
from . import Function as _Function
from . import LayerVersion as _LayerVersion
from . import Url as _Url
from . import Version as _Version


# Resources
# ============================================================


@dataclass
class Alias(CloudFormationResource):
    """Alias resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-alias.html

    CloudFormation type: AWS::Lambda::Alias
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::Alias"

    function_name: DslValue[str] | None = None
    function_version: DslValue[str] | None = None
    name: DslValue[str] | None = None
    description: DslValue[str] | None = None
    provisioned_concurrency_config: (
        DslValue[_Alias.ProvisionedConcurrencyConfiguration] | None
    ) = None
    routing_config: DslValue[_Alias.AliasRoutingConfiguration] | None = None

    # GetAtt attributes
    ALIASARN: ClassVar[str] = "AliasArn"

    # PropertyType descriptors for nested GetAtt support
    AliasRoutingConfiguration = PropertyTypeDescriptor(
        _Alias.AliasRoutingConfiguration, "AliasRoutingConfiguration"
    )
    ProvisionedConcurrencyConfiguration = PropertyTypeDescriptor(
        _Alias.ProvisionedConcurrencyConfiguration,
        "ProvisionedConcurrencyConfiguration",
    )
    VersionWeight = PropertyTypeDescriptor(_Alias.VersionWeight, "VersionWeight")


@dataclass
class CapacityProvider(CloudFormationResource):
    """CapacityProvider resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-capacityprovider.html

    CloudFormation type: AWS::Lambda::CapacityProvider
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::CapacityProvider"

    permissions_config: (
        DslValue[_CapacityProvider.CapacityProviderPermissionsConfig] | None
    ) = None
    vpc_config: DslValue[_CapacityProvider.CapacityProviderVpcConfig] | None = None
    capacity_provider_name: DslValue[str] | None = None
    capacity_provider_scaling_config: (
        DslValue[_CapacityProvider.CapacityProviderScalingConfig] | None
    ) = None
    instance_requirements: DslValue[_CapacityProvider.InstanceRequirements] | None = (
        None
    )
    kms_key_arn: DslValue[str] | None = None
    tags: list[DslValue[Tag]] = field(default_factory=list)

    # GetAtt attributes
    STATE: ClassVar[str] = "State"
    ARN: ClassVar[str] = "Arn"

    # PropertyType descriptors for nested GetAtt support
    CapacityProviderPermissionsConfig = PropertyTypeDescriptor(
        _CapacityProvider.CapacityProviderPermissionsConfig,
        "CapacityProviderPermissionsConfig",
    )
    CapacityProviderScalingConfig = PropertyTypeDescriptor(
        _CapacityProvider.CapacityProviderScalingConfig, "CapacityProviderScalingConfig"
    )
    CapacityProviderVpcConfig = PropertyTypeDescriptor(
        _CapacityProvider.CapacityProviderVpcConfig, "CapacityProviderVpcConfig"
    )
    InstanceRequirements = PropertyTypeDescriptor(
        _CapacityProvider.InstanceRequirements, "InstanceRequirements"
    )
    TargetTrackingScalingPolicy = PropertyTypeDescriptor(
        _CapacityProvider.TargetTrackingScalingPolicy, "TargetTrackingScalingPolicy"
    )


@dataclass
class CodeSigningConfig(CloudFormationResource):
    """CodeSigningConfig resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-codesigningconfig.html

    CloudFormation type: AWS::Lambda::CodeSigningConfig
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::CodeSigningConfig"

    allowed_publishers: DslValue[_CodeSigningConfig.AllowedPublishers] | None = None
    code_signing_policies: DslValue[_CodeSigningConfig.CodeSigningPolicies] | None = (
        None
    )
    description: DslValue[str] | None = None
    tags: list[DslValue[Tag]] = field(default_factory=list)

    # GetAtt attributes
    CODESIGNINGCONFIGID: ClassVar[str] = "CodeSigningConfigId"
    CODESIGNINGCONFIGARN: ClassVar[str] = "CodeSigningConfigArn"

    # PropertyType descriptors for nested GetAtt support
    AllowedPublishers = PropertyTypeDescriptor(
        _CodeSigningConfig.AllowedPublishers, "AllowedPublishers"
    )
    CodeSigningPolicies = PropertyTypeDescriptor(
        _CodeSigningConfig.CodeSigningPolicies, "CodeSigningPolicies"
    )


@dataclass
class EventInvokeConfig(CloudFormationResource):
    """EventInvokeConfig resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-eventinvokeconfig.html

    CloudFormation type: AWS::Lambda::EventInvokeConfig
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::EventInvokeConfig"

    function_name: DslValue[str] | None = None
    qualifier: DslValue[str] | None = None
    destination_config: DslValue[_EventInvokeConfig.DestinationConfig] | None = None
    maximum_event_age_in_seconds: DslValue[int] | None = None
    maximum_retry_attempts: DslValue[int] | None = None

    # PropertyType descriptors for nested GetAtt support
    DestinationConfig = PropertyTypeDescriptor(
        _EventInvokeConfig.DestinationConfig, "DestinationConfig"
    )
    OnFailure = PropertyTypeDescriptor(_EventInvokeConfig.OnFailure, "OnFailure")
    OnSuccess = PropertyTypeDescriptor(_EventInvokeConfig.OnSuccess, "OnSuccess")


@dataclass
class EventSourceMapping(CloudFormationResource):
    """EventSourceMapping resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-eventsourcemapping.html

    CloudFormation type: AWS::Lambda::EventSourceMapping
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::EventSourceMapping"
    _property_mappings: ClassVar[dict[str, str]] = {
        "document_db_event_source_config": "DocumentDBEventSourceConfig",
    }

    function_name: DslValue[str] | None = None
    amazon_managed_kafka_event_source_config: (
        DslValue[_EventSourceMapping.AmazonManagedKafkaEventSourceConfig] | None
    ) = None
    batch_size: DslValue[int] | None = None
    bisect_batch_on_function_error: DslValue[bool] | None = None
    destination_config: DslValue[_EventSourceMapping.DestinationConfig] | None = None
    document_db_event_source_config: (
        DslValue[_EventSourceMapping.DocumentDBEventSourceConfig] | None
    ) = None
    enabled: DslValue[bool] | None = None
    event_source_arn: DslValue[str] | None = None
    filter_criteria: DslValue[_EventSourceMapping.FilterCriteria] | None = None
    function_response_types: list[DslValue[str]] = field(default_factory=list)
    kms_key_arn: DslValue[str] | None = None
    logging_config: DslValue[_EventSourceMapping.LoggingConfig] | None = None
    maximum_batching_window_in_seconds: DslValue[int] | None = None
    maximum_record_age_in_seconds: DslValue[int] | None = None
    maximum_retry_attempts: DslValue[int] | None = None
    metrics_config: DslValue[_EventSourceMapping.MetricsConfig] | None = None
    parallelization_factor: DslValue[int] | None = None
    provisioned_poller_config: (
        DslValue[_EventSourceMapping.ProvisionedPollerConfig] | None
    ) = None
    queues: list[DslValue[str]] = field(default_factory=list)
    scaling_config: DslValue[_EventSourceMapping.ScalingConfig] | None = None
    self_managed_event_source: (
        DslValue[_EventSourceMapping.SelfManagedEventSource] | None
    ) = None
    self_managed_kafka_event_source_config: (
        DslValue[_EventSourceMapping.SelfManagedKafkaEventSourceConfig] | None
    ) = None
    source_access_configurations: list[
        DslValue[_EventSourceMapping.SourceAccessConfiguration]
    ] = field(default_factory=list)
    starting_position: DslValue[str] | None = None
    starting_position_timestamp: DslValue[float] | None = None
    tags: list[DslValue[Tag]] = field(default_factory=list)
    topics: list[DslValue[str]] = field(default_factory=list)
    tumbling_window_in_seconds: DslValue[int] | None = None

    # GetAtt attributes
    EVENTSOURCEMAPPINGARN: ClassVar[str] = "EventSourceMappingArn"
    ID: ClassVar[str] = "Id"

    # PropertyType descriptors for nested GetAtt support
    AmazonManagedKafkaEventSourceConfig = PropertyTypeDescriptor(
        _EventSourceMapping.AmazonManagedKafkaEventSourceConfig,
        "AmazonManagedKafkaEventSourceConfig",
    )
    DestinationConfig = PropertyTypeDescriptor(
        _EventSourceMapping.DestinationConfig, "DestinationConfig"
    )
    DocumentDBEventSourceConfig = PropertyTypeDescriptor(
        _EventSourceMapping.DocumentDBEventSourceConfig, "DocumentDBEventSourceConfig"
    )
    Endpoints = PropertyTypeDescriptor(_EventSourceMapping.Endpoints, "Endpoints")
    Filter = PropertyTypeDescriptor(_EventSourceMapping.Filter, "Filter")
    FilterCriteria = PropertyTypeDescriptor(
        _EventSourceMapping.FilterCriteria, "FilterCriteria"
    )
    LoggingConfig = PropertyTypeDescriptor(
        _EventSourceMapping.LoggingConfig, "LoggingConfig"
    )
    MetricsConfig = PropertyTypeDescriptor(
        _EventSourceMapping.MetricsConfig, "MetricsConfig"
    )
    OnFailure = PropertyTypeDescriptor(_EventSourceMapping.OnFailure, "OnFailure")
    ProvisionedPollerConfig = PropertyTypeDescriptor(
        _EventSourceMapping.ProvisionedPollerConfig, "ProvisionedPollerConfig"
    )
    ScalingConfig = PropertyTypeDescriptor(
        _EventSourceMapping.ScalingConfig, "ScalingConfig"
    )
    SchemaRegistryAccessConfig = PropertyTypeDescriptor(
        _EventSourceMapping.SchemaRegistryAccessConfig, "SchemaRegistryAccessConfig"
    )
    SchemaRegistryConfig = PropertyTypeDescriptor(
        _EventSourceMapping.SchemaRegistryConfig, "SchemaRegistryConfig"
    )
    SchemaValidationConfig = PropertyTypeDescriptor(
        _EventSourceMapping.SchemaValidationConfig, "SchemaValidationConfig"
    )
    SelfManagedEventSource = PropertyTypeDescriptor(
        _EventSourceMapping.SelfManagedEventSource, "SelfManagedEventSource"
    )
    SelfManagedKafkaEventSourceConfig = PropertyTypeDescriptor(
        _EventSourceMapping.SelfManagedKafkaEventSourceConfig,
        "SelfManagedKafkaEventSourceConfig",
    )
    SourceAccessConfiguration = PropertyTypeDescriptor(
        _EventSourceMapping.SourceAccessConfiguration, "SourceAccessConfiguration"
    )


@dataclass
class Function(CloudFormationResource):
    """Function resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html

    CloudFormation type: AWS::Lambda::Function
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::Function"

    code: DslValue[_Function.Code] | None = None
    role: DslValue[str] | None = None
    architectures: list[DslValue[str]] = field(default_factory=list)
    capacity_provider_config: DslValue[_Function.CapacityProviderConfig] | None = None
    code_signing_config_arn: DslValue[str] | None = None
    dead_letter_config: DslValue[_Function.DeadLetterConfig] | None = None
    description: DslValue[str] | None = None
    durable_config: DslValue[_Function.DurableConfig] | None = None
    environment: DslValue[_Function.Environment] | None = None
    ephemeral_storage: DslValue[_Function.EphemeralStorage] | None = None
    file_system_configs: list[DslValue[_Function.FileSystemConfig]] = field(
        default_factory=list
    )
    function_name: DslValue[str] | None = None
    function_scaling_config: DslValue[_Function.FunctionScalingConfig] | None = None
    handler: DslValue[str] | None = None
    image_config: DslValue[_Function.ImageConfig] | None = None
    kms_key_arn: DslValue[str] | None = None
    layers: list[DslValue[str]] = field(default_factory=list)
    logging_config: DslValue[_Function.LoggingConfig] | None = None
    memory_size: DslValue[int] | None = None
    package_type: DslValue[str] | None = None
    publish_to_latest_published: DslValue[bool] | None = None
    recursive_loop: DslValue[str] | None = None
    reserved_concurrent_executions: DslValue[int] | None = None
    runtime: DslValue[str] | None = None
    runtime_management_config: DslValue[_Function.RuntimeManagementConfig] | None = None
    snap_start: DslValue[_Function.SnapStart] | None = None
    tags: list[DslValue[Tag]] = field(default_factory=list)
    tenancy_config: DslValue[_Function.TenancyConfig] | None = None
    timeout: DslValue[int] | None = None
    tracing_config: DslValue[_Function.TracingConfig] | None = None
    vpc_config: DslValue[_Function.VpcConfig] | None = None

    # GetAtt attributes
    SNAPSTARTRESPONSE_OPTIMIZATIONSTATUS: ClassVar[str] = (
        "SnapStartResponse.OptimizationStatus"
    )
    SNAPSTARTRESPONSE_APPLYON: ClassVar[str] = "SnapStartResponse.ApplyOn"
    SNAPSTARTRESPONSE: ClassVar[str] = "SnapStartResponse"
    ARN: ClassVar[str] = "Arn"

    # PropertyType descriptors for nested GetAtt support
    CapacityProviderConfig = PropertyTypeDescriptor(
        _Function.CapacityProviderConfig, "CapacityProviderConfig"
    )
    Code = PropertyTypeDescriptor(_Function.Code, "Code")
    DeadLetterConfig = PropertyTypeDescriptor(
        _Function.DeadLetterConfig, "DeadLetterConfig"
    )
    DurableConfig = PropertyTypeDescriptor(_Function.DurableConfig, "DurableConfig")
    Environment = PropertyTypeDescriptor(_Function.Environment, "Environment")
    EphemeralStorage = PropertyTypeDescriptor(
        _Function.EphemeralStorage, "EphemeralStorage"
    )
    FileSystemConfig = PropertyTypeDescriptor(
        _Function.FileSystemConfig, "FileSystemConfig"
    )
    FunctionScalingConfig = PropertyTypeDescriptor(
        _Function.FunctionScalingConfig, "FunctionScalingConfig"
    )
    ImageConfig = PropertyTypeDescriptor(_Function.ImageConfig, "ImageConfig")
    LambdaManagedInstancesCapacityProviderConfig = PropertyTypeDescriptor(
        _Function.LambdaManagedInstancesCapacityProviderConfig,
        "LambdaManagedInstancesCapacityProviderConfig",
    )
    LoggingConfig = PropertyTypeDescriptor(_Function.LoggingConfig, "LoggingConfig")
    RuntimeManagementConfig = PropertyTypeDescriptor(
        _Function.RuntimeManagementConfig, "RuntimeManagementConfig"
    )
    SnapStart = PropertyTypeDescriptor(_Function.SnapStart, "SnapStart")
    SnapStartResponse = PropertyTypeDescriptor(
        _Function.SnapStartResponse, "SnapStartResponse"
    )
    TenancyConfig = PropertyTypeDescriptor(_Function.TenancyConfig, "TenancyConfig")
    TracingConfig = PropertyTypeDescriptor(_Function.TracingConfig, "TracingConfig")
    VpcConfig = PropertyTypeDescriptor(_Function.VpcConfig, "VpcConfig")


@dataclass
class LayerVersion(CloudFormationResource):
    """LayerVersion resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-layerversion.html

    CloudFormation type: AWS::Lambda::LayerVersion
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::LayerVersion"

    content: DslValue[_LayerVersion.Content] | None = None
    compatible_architectures: list[DslValue[str]] = field(default_factory=list)
    compatible_runtimes: list[DslValue[str]] = field(default_factory=list)
    description: DslValue[str] | None = None
    layer_name: DslValue[str] | None = None
    license_info: DslValue[str] | None = None

    # GetAtt attributes
    LAYERVERSIONARN: ClassVar[str] = "LayerVersionArn"

    # PropertyType descriptors for nested GetAtt support
    Content = PropertyTypeDescriptor(_LayerVersion.Content, "Content")


@dataclass
class LayerVersionPermission(CloudFormationResource):
    """LayerVersionPermission resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-layerversionpermission.html

    CloudFormation type: AWS::Lambda::LayerVersionPermission
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::LayerVersionPermission"

    action: DslValue[str] | None = None
    layer_version_arn: DslValue[str] | None = None
    principal: DslValue[str] | None = None
    organization_id: DslValue[str] | None = None

    # GetAtt attributes
    ID: ClassVar[str] = "Id"


@dataclass
class Permission(CloudFormationResource):
    """Permission resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html

    CloudFormation type: AWS::Lambda::Permission
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::Permission"
    _property_mappings: ClassVar[dict[str, str]] = {
        "principal_org_id": "PrincipalOrgID",
    }

    action: DslValue[str] | None = None
    function_name: DslValue[str] | None = None
    principal: DslValue[str] | None = None
    event_source_token: DslValue[str] | None = None
    function_url_auth_type: DslValue[str] | None = None
    invoked_via_function_url: DslValue[bool] | None = None
    principal_org_id: DslValue[str] | None = None
    source_account: DslValue[str] | None = None
    source_arn: DslValue[str] | None = None

    # GetAtt attributes
    ID: ClassVar[str] = "Id"


@dataclass
class Url(CloudFormationResource):
    """Url resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-url.html

    CloudFormation type: AWS::Lambda::Url
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::Url"

    auth_type: DslValue[str] | None = None
    target_function_arn: DslValue[str] | None = None
    cors: DslValue[_Url.Cors] | None = None
    invoke_mode: DslValue[str] | None = None
    qualifier: DslValue[str] | None = None

    # GetAtt attributes
    FUNCTIONARN: ClassVar[str] = "FunctionArn"
    FUNCTIONURL: ClassVar[str] = "FunctionUrl"

    # PropertyType descriptors for nested GetAtt support
    Cors = PropertyTypeDescriptor(_Url.Cors, "Cors")


@dataclass
class Version(CloudFormationResource):
    """Version resource.

    http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-version.html

    CloudFormation type: AWS::Lambda::Version
    """

    _resource_type: ClassVar[str] = "AWS::Lambda::Version"

    function_name: DslValue[str] | None = None
    code_sha256: DslValue[str] | None = None
    description: DslValue[str] | None = None
    function_scaling_config: DslValue[_Version.FunctionScalingConfig] | None = None
    provisioned_concurrency_config: (
        DslValue[_Version.ProvisionedConcurrencyConfiguration] | None
    ) = None
    runtime_policy: DslValue[_Version.RuntimePolicy] | None = None

    # GetAtt attributes
    FUNCTIONARN: ClassVar[str] = "FunctionArn"
    VERSION: ClassVar[str] = "Version"

    # PropertyType descriptors for nested GetAtt support
    FunctionScalingConfig = PropertyTypeDescriptor(
        _Version.FunctionScalingConfig, "FunctionScalingConfig"
    )
    ProvisionedConcurrencyConfiguration = PropertyTypeDescriptor(
        _Version.ProvisionedConcurrencyConfiguration,
        "ProvisionedConcurrencyConfiguration",
    )
    RuntimePolicy = PropertyTypeDescriptor(_Version.RuntimePolicy, "RuntimePolicy")

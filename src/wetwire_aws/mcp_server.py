"""MCP server exposing wetwire-aws tools.

This module provides a Model Context Protocol (MCP) server that exposes
wetwire-aws functionality as tools for AI agents like Kiro CLI.

Tools:
    wetwire_init: Initialize a new wetwire-aws package
    wetwire_lint: Lint Python code for wetwire-aws issues
    wetwire_build: Generate CloudFormation template from a package

Usage:
    # Run as standalone server (stdio transport)
    wetwire-aws-mcp

    # Configure in Kiro's mcp.json:
    {
        "mcpServers": {
            "wetwire-aws-mcp": {
                "command": "wetwire-aws-mcp"
            }
        }
    }
"""

from __future__ import annotations

import sys
from dataclasses import asdict
from pathlib import Path
from typing import Any

from wetwire_core.mcp import create_server, register_tool, run_server


def _create_package(path: str, module_name: str) -> dict[str, Any]:
    """Create a new wetwire-aws package.

    Args:
        path: Directory where the package should be created.
        module_name: Name of the package (snake_case).

    Returns:
        Dict with 'success' and 'message' or 'error' keys.
    """
    output_dir = Path(path)
    if not output_dir.exists():
        return {"success": False, "error": f"Directory does not exist: {path}"}

    if not module_name.replace("_", "").isalnum():
        return {
            "success": False,
            "error": f"Invalid module name '{module_name}'. Use snake_case.",
        }

    package_dir = output_dir / module_name

    if package_dir.exists():
        return {
            "success": False,
            "error": f"Package already exists: {package_dir}",
        }

    # Create package directory
    package_dir.mkdir(parents=True, exist_ok=True)

    # Create __init__.py with setup_params and setup_resources
    init_content = f'''"""{module_name} infrastructure

Generated by wetwire-aws init.
"""

from wetwire_aws.loader import setup_params, setup_resources

setup_params(globals())

from .params import *  # noqa: F403, F401

setup_resources(__file__, __name__, globals())
'''
    (package_dir / "__init__.py").write_text(init_content)

    # Create empty params.py
    params_content = '''"""Parameters, Mappings, and Conditions."""

from . import *  # noqa: F403

# Define parameters here, e.g.:
# class BucketName(Parameter):
#     type = STRING
#     description = "Name of the S3 bucket"
#     default = "my-bucket"
'''
    (package_dir / "params.py").write_text(params_content)

    return {
        "success": True,
        "message": f"Created package: {package_dir}",
        "path": str(package_dir),
    }


def _lint_path(path: str, fix: bool = False) -> dict[str, Any]:
    """Lint Python files for wetwire-aws issues.

    Args:
        path: Path to a Python file or directory.
        fix: If True, auto-fix detected issues.

    Returns:
        Dict with 'issues' list or 'fixed_files' if fix=True.
    """
    from wetwire_aws.linter import fix_file, lint_file

    target = Path(path)
    if not target.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}

    # Collect files to lint
    if target.is_file():
        files = [target]
    else:
        files = list(target.rglob("*.py"))
        # Exclude __pycache__ and hidden directories
        files = [
            f
            for f in files
            if "__pycache__" not in str(f) and not any(p.startswith(".") for p in f.parts)
        ]

    if not files:
        return {"success": True, "issues": [], "message": "No Python files found."}

    all_issues: list[dict[str, Any]] = []
    fixed_files: list[str] = []

    for filepath in files:
        if fix:
            original = filepath.read_text()
            fixed = fix_file(str(filepath), write=True)
            if fixed != original:
                fixed_files.append(str(filepath))
        else:
            issues = lint_file(str(filepath))
            for issue in issues:
                issue_dict = asdict(issue)
                issue_dict["file"] = str(filepath)
                all_issues.append(issue_dict)

    if fix:
        return {
            "success": True,
            "fixed_files": fixed_files,
            "message": f"Fixed {len(fixed_files)} files.",
        }
    else:
        return {
            "success": True,
            "issues": all_issues,
            "issue_count": len(all_issues),
            "file_count": len(files),
        }


def _build_template(path: str, output_format: str = "json") -> dict[str, Any]:
    """Generate CloudFormation template from a wetwire-aws package.

    Args:
        path: Path to the package directory.
        output_format: Output format, either 'json' or 'yaml'.

    Returns:
        Dict with 'template' containing the generated CloudFormation template.
    """
    from wetwire_aws.cli_utils import discover_resources
    from wetwire_aws.decorator import get_aws_registry
    from wetwire_aws.template import CloudFormationTemplate

    package_path = Path(path).resolve()
    if not package_path.exists():
        return {"success": False, "error": f"Path does not exist: {path}"}
    if not package_path.is_dir():
        return {"success": False, "error": f"Path is not a directory: {path}"}
    if not (package_path / "__init__.py").exists():
        return {
            "success": False,
            "error": f"Path is not a Python package (missing __init__.py): {path}",
        }

    # Add parent directory to sys.path and use directory name as module
    parent_dir = str(package_path.parent)
    if parent_dir not in sys.path:
        sys.path.insert(0, parent_dir)

    module_name = package_path.name

    # Force reimport by clearing cached modules
    # This ensures new files are picked up and stubs are regenerated
    modules_to_remove = [
        key for key in sys.modules
        if key == module_name or key.startswith(f"{module_name}.")
    ]
    for mod in modules_to_remove:
        del sys.modules[mod]

    registry = get_aws_registry()
    discover_resources(module_name, registry, verbose=False)

    # Check if any resources are registered
    resources = list(registry.get_all(None))
    if not resources:
        return {
            "success": False,
            "error": "No resources registered. Ensure your package has resource classes.",
        }

    # Generate template
    template = CloudFormationTemplate.from_registry(scope_package=None)

    if output_format == "yaml":
        try:
            output = template.to_yaml()
        except ImportError:
            return {
                "success": False,
                "error": "PyYAML required for YAML output. Install with: pip install pyyaml",
            }
    else:
        output = template.to_json(indent=2)

    return {
        "success": True,
        "template": output,
        "resource_count": len(template.resources),
        "format": output_format,
    }


# Tool handlers for wetwire-core MCP registration
def _handle_init(arguments: dict[str, Any]) -> dict[str, Any]:
    """Handle wetwire_init tool call."""
    return _create_package(
        path=arguments["path"],
        module_name=arguments["module_name"],
    )


def _handle_lint(arguments: dict[str, Any]) -> dict[str, Any]:
    """Handle wetwire_lint tool call."""
    return _lint_path(
        path=arguments["path"],
        fix=arguments.get("fix", False),
    )


def _handle_build(arguments: dict[str, Any]) -> dict[str, Any]:
    """Handle wetwire_build tool call."""
    return _build_template(
        path=arguments["path"],
        output_format=arguments.get("format", "json"),
    )


# Tool schemas
INIT_SCHEMA = {
    "type": "object",
    "properties": {
        "path": {
            "type": "string",
            "description": "Directory where the package should be created",
        },
        "module_name": {
            "type": "string",
            "description": "Name of the package (snake_case, e.g., 'my_app')",
        },
    },
    "required": ["path", "module_name"],
}

LINT_SCHEMA = {
    "type": "object",
    "properties": {
        "path": {
            "type": "string",
            "description": "Path to Python file or directory to lint",
        },
        "fix": {
            "type": "boolean",
            "description": "Auto-fix detected issues (default: false)",
            "default": False,
        },
    },
    "required": ["path"],
}

BUILD_SCHEMA = {
    "type": "object",
    "properties": {
        "path": {
            "type": "string",
            "description": "Path to the wetwire-aws package directory",
        },
        "format": {
            "type": "string",
            "enum": ["json", "yaml"],
            "description": "Output format (default: json)",
            "default": "json",
        },
    },
    "required": ["path"],
}


def main() -> None:
    """Main entry point for the MCP server."""
    # Create server using wetwire-core abstraction
    server = create_server("wetwire-aws-mcp")

    # Register tools
    register_tool(
        server,
        "wetwire_init",
        _handle_init,
        INIT_SCHEMA,
        description="Initialize a new wetwire-aws infrastructure package",
    )
    register_tool(
        server,
        "wetwire_lint",
        _handle_lint,
        LINT_SCHEMA,
        description="Lint Python code for wetwire-aws issues (WAW001-WAW022)",
    )
    register_tool(
        server,
        "wetwire_build",
        _handle_build,
        BUILD_SCHEMA,
        description="Generate CloudFormation template from a wetwire-aws package",
    )

    # Run the server
    run_server(server)


if __name__ == "__main__":
    main()

"""Package generation for multi-file output.

This module generates complete Python packages from CloudFormation templates,
organizing code into multiple files:

- __init__.py: Centralized imports and setup_resources()
- __main__.py: Entry point for python -m package_name
- params.py: Parameters, Mappings, and Conditions
- outputs.py: Output definitions
- main.py: Resources (or categorized files for large templates)

Key functions:
- generate_code(): Single-file output for simple templates
- generate_package(): Multi-file package output
"""

from __future__ import annotations

from wetwire_aws.importer.ir import IRTemplate

from .classes import (
    generate_condition_class,
    generate_mapping_class,
    generate_output_class,
    generate_parameter_class,
    generate_resource_class,
)
from .context import (
    CodegenContext,
    PackageContext,
    build_arn_pattern_map,
    build_name_pattern_map,
)
from .helpers import get_resource_category, sanitize_class_name
from .imports import generate_imports
from .topology import (
    find_resource_dependencies,
    find_strongly_connected_components,
    topological_sort,
)
from .values import escape_string

# =============================================================================
# Single File Generation
# =============================================================================


def generate_code(
    template: IRTemplate,
    include_main: bool = True,
) -> str:
    """
    Generate Python code from analyzed IR.

    Args:
        template: Parsed IRTemplate
        include_main: Include if __name__ == "__main__" block

    Returns:
        Complete Python module source code
    """
    ctx = CodegenContext(
        template=template,
        include_main_block=include_main,
    )

    ctx.name_pattern_map = build_name_pattern_map(template)
    ctx.arn_pattern_map = build_arn_pattern_map(template)

    # Add common imports
    ctx.add_import("wetwire_aws", "ref")
    ctx.add_import("wetwire_aws", "get_att")

    sections: list[str] = []

    # Module docstring
    if template.description:
        sections.append(
            f'"""\n{template.description}\n\nGenerated by wetwire-aws import.\n"""'
        )
    else:
        sections.append('"""Generated by wetwire-aws import."""')

    class_sections: list[str] = []

    # Parameters
    for param in template.parameters.values():
        class_sections.append(generate_parameter_class(param, ctx))

    # Mappings
    for mapping in template.mappings.values():
        class_sections.append(generate_mapping_class(mapping, ctx))

    # Conditions
    for condition in template.conditions.values():
        class_sections.append(generate_condition_class(condition, ctx))

    # Resources (in dependency order)
    sorted_resources = topological_sort(template)
    resource_classes = []
    for resource_id in sorted_resources:
        resource = template.resources[resource_id]
        resource_class = generate_resource_class(resource, ctx)
        resource_classes.append(resource_class)

    # Add PropertyType wrapper classes (generated during resource class generation)
    # They go before the resource classes that use them
    for pt_class_def in ctx.property_type_class_defs:
        class_sections.append(pt_class_def)
    ctx.property_type_class_defs.clear()

    # Now add resource classes
    class_sections.extend(resource_classes)

    # Outputs
    for output in template.outputs.values():
        class_sections.append(generate_output_class(output, ctx))

    # Now generate imports
    ctx.add_import("wetwire_aws", "CloudFormationTemplate")
    sections.append(generate_imports(ctx))

    # Add class sections
    sections.extend(s for s in class_sections if s)

    # Build template function
    param_list = ""
    if template.parameters:
        param_names = ", ".join(template.parameters.keys())
        param_list = f"parameters=[{param_names}]"

    output_list = ""
    if template.outputs:
        output_names = ", ".join(f"{lid}Output" for lid in template.outputs.keys())
        output_list = f"outputs=[{output_names}]"

    args = []
    if template.description:
        args.append(f"description={escape_string(template.description)}")
    if param_list:
        args.append(param_list)
    if output_list:
        args.append(output_list)

    if args:
        args_str = ",\n        ".join(args)
        from_registry_call = (
            f"CloudFormationTemplate.from_registry(\n        {args_str},\n    )"
        )
    else:
        from_registry_call = "CloudFormationTemplate.from_registry()"

    sections.append(
        f"""
def build_template() -> CloudFormationTemplate:
    \"\"\"Build the CloudFormation template.\"\"\"
    return {from_registry_call}"""
    )

    # Main block
    if include_main:
        sections.append(
            """
if __name__ == "__main__":
    import json
    template = build_template()
    print(json.dumps(template.to_dict(), indent=2))"""
        )

    return "\n\n\n".join(sections) + "\n"


# =============================================================================
# Package Generation
# =============================================================================


def generate_package(
    template: IRTemplate,
    package_name: str,
) -> dict[str, str]:
    """
    Generate a Python package from template (multi-file output).

    Args:
        template: Parsed IRTemplate
        package_name: Name of the Python package

    Returns:
        Dict mapping filename to content, prefixed by package_name/
    """
    pkg_ctx = PackageContext(template=template)
    ctx = pkg_ctx.codegen_ctx

    ctx.add_import("wetwire_aws", "ref")
    ctx.add_import("wetwire_aws", "get_att")
    ctx.add_import("wetwire_aws", "CloudFormationTemplate")

    # Generate params.py
    params_content = _generate_params_py(pkg_ctx, template)

    # Generate outputs.py
    outputs_content = _generate_outputs_py(pkg_ctx, template)

    # Generate resource files
    resource_files = _generate_resource_files(pkg_ctx, template)

    # Generate __init__.py last
    init_content = _generate_init_py(pkg_ctx, template)

    # Generate __main__.py
    dunder_main_content = f'''"""Allow running as: python -m {package_name}."""
from wetwire_aws.cli import main

if __name__ == "__main__":
    main()
'''

    files = {
        f"{package_name}/__init__.py": init_content,
        f"{package_name}/__main__.py": dunder_main_content,
        f"{package_name}/params.py": params_content,
    }

    if outputs_content:
        files[f"{package_name}/outputs.py"] = outputs_content

    for filename, content in resource_files.items():
        files[f"{package_name}/{filename}"] = content

    return files


# =============================================================================
# Init File Generation
# =============================================================================


def _generate_init_py(pkg_ctx: PackageContext, template: IRTemplate) -> str:
    """Generate __init__.py with setup_params() and setup_resources().

    The __init__.py uses setup_params() to inject all types needed by params.py,
    then calls setup_resources() which loads resource files in dependency order.
    """
    lines = []

    # Docstring
    if template.description:
        desc = template.description.strip()
        if len(desc) > 200:
            desc = desc[:197] + "..."
        lines.append(f'"""{desc}\n\nGenerated by wetwire-aws import."""')
    else:
        lines.append('"""Generated by wetwire-aws import."""')

    lines.append("")

    # Minimal imports - just the setup functions
    lines.append("from wetwire_aws.loader import setup_params, setup_resources")
    lines.append("")

    # Inject types needed by params.py
    lines.append("setup_params(globals())")
    lines.append("")

    # Import params (now works because setup_params injected everything)
    lines.append("from .params import *  # noqa: F403, F401")
    lines.append("")

    # Setup resources - loads all resource and output files, auto-decorates classes
    # No need for explicit imports after this - everything is in globals()
    lines.append("setup_resources(__file__, __name__, globals())")
    lines.append("")

    return "\n".join(lines) + "\n"


# =============================================================================
# Params File Generation
# =============================================================================


def _generate_params_py(pkg_ctx: PackageContext, template: IRTemplate) -> str:
    """Generate params.py with Parameters, Mappings, Conditions."""
    lines = []
    lines.append('"""Parameters, Mappings, and Conditions."""')
    lines.append("")
    lines.append("from . import *  # noqa: F403")
    lines.append("")
    lines.append("")

    ctx = pkg_ctx.codegen_ctx

    # Parameters
    for param in template.parameters.values():
        class_def = generate_parameter_class(param, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(sanitize_class_name(param.logical_id))

    # Mappings
    for mapping in template.mappings.values():
        class_def = generate_mapping_class(mapping, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(f"{sanitize_class_name(mapping.logical_id)}Mapping")

    # Conditions
    for condition in template.conditions.values():
        class_def = generate_condition_class(condition, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.config_exports.add(
            f"{sanitize_class_name(condition.logical_id)}Condition"
        )

    while lines and lines[-1] == "":
        lines.pop()

    return "\n".join(lines) + "\n"


# =============================================================================
# Outputs File Generation
# =============================================================================


def _generate_outputs_py(pkg_ctx: PackageContext, template: IRTemplate) -> str | None:
    """Generate outputs.py with Output definitions."""
    if not template.outputs:
        return None

    lines = []
    lines.append('"""Template outputs."""')
    lines.append("")
    lines.append("from . import *  # noqa: F403")
    lines.append("")
    lines.append("")

    ctx = pkg_ctx.codegen_ctx

    for output in template.outputs.values():
        class_def = generate_output_class(output, ctx)
        lines.append(class_def)
        lines.append("")
        lines.append("")
        pkg_ctx.outputs_exports.add(f"{output.logical_id}Output")

    while lines and lines[-1] == "":
        lines.pop()

    return "\n".join(lines) + "\n"


# =============================================================================
# Resource Files Generation
# =============================================================================


def _find_file_cycle(file_deps: dict[str, set[str]]) -> list[str] | None:
    """Detect cycles in file-level dependency graph using DFS.

    Args:
        file_deps: Dict mapping file name -> set of file names it depends on.

    Returns:
        List of file names forming a cycle, or None if no cycle found.
    """
    visited: set[str] = set()
    rec_stack: set[str] = set()  # Tracks nodes in current recursion path
    path: list[str] = []

    def dfs(node: str) -> list[str] | None:
        visited.add(node)
        rec_stack.add(node)
        path.append(node)

        for neighbor in file_deps.get(node, set()):
            if neighbor not in visited:
                result = dfs(neighbor)
                if result:
                    return result
            elif neighbor in rec_stack:
                # Found cycle - return the cycle portion
                cycle_start = path.index(neighbor)
                return path[cycle_start:]

        path.pop()
        rec_stack.remove(node)
        return None

    # Try DFS from each unvisited node
    for node in file_deps:
        if node not in visited:
            result = dfs(node)
            if result:
                return result

    return None


def _generate_resource_files(
    pkg_ctx: PackageContext, template: IRTemplate
) -> dict[str, str]:
    """Generate resource files.

    With two-pass loading and placeholder support in dataclass-dsl, forward
    references within the same file are handled automatically. We still use
    SCCs to group tightly-coupled resources together in main.py, but ordering
    within files is no longer required for correctness.
    """
    files = {}
    ctx = pkg_ctx.codegen_ctx

    sccs = find_strongly_connected_components(template)

    resource_to_scc: dict[str, int] = {}
    for scc_idx, scc in enumerate(sccs):
        for resource_id in scc:
            resource_to_scc[resource_id] = scc_idx

    sorted_resources = topological_sort(template)

    # First: categorize resources into files BEFORE generating code
    # This allows the code generator to know which file each resource is in
    main_py_resources: list[str] = []
    separate_files: dict[str, list[str]] = {}
    generated_sccs: set[int] = set()

    for resource_id in sorted_resources:
        scc_idx = resource_to_scc[resource_id]
        if scc_idx in generated_sccs:
            continue
        generated_sccs.add(scc_idx)

        scc = sccs[scc_idx]

        if len(scc) > 1:
            # Multi-resource SCCs go to main.py to keep cycles together
            main_py_resources.extend(scc)
        else:
            resource = template.resources[resource_id]
            category = get_resource_category(resource)
            if category == "main":
                main_py_resources.append(resource_id)
            else:
                if category not in separate_files:
                    separate_files[category] = []
                separate_files[category].append(resource_id)

    # Build resource -> file mapping
    resource_to_file: dict[str, str] = {}
    for rid in main_py_resources:
        resource_to_file[rid] = "main"
    for category, rids in separate_files.items():
        for rid in rids:
            resource_to_file[rid] = category

    # Build resource dependency graph for cycle detection
    name_pattern_map = ctx.name_pattern_map
    arn_pattern_map = ctx.arn_pattern_map
    all_resource_deps: dict[str, set[str]] = {}
    for rid in sorted_resources:
        deps = find_resource_dependencies(
            template, rid, name_pattern_map, arn_pattern_map
        )
        all_resource_deps[rid] = deps

    # Detect and break file-level cycles by moving minimal resources to main.py
    # File-level cycles break the loader's topological sort
    for _ in range(len(separate_files) * 2 + 1):
        # Build file dependency graph and track which resources create cross-file deps
        file_deps: dict[str, set[str]] = {"main": set()}
        # Track resources that create each cross-file edge: (from_file, to_file) -> [resources]
        cross_file_resources: dict[tuple[str, str], list[str]] = {}

        for cat in separate_files:
            file_deps[cat] = set()

        for rid, deps in all_resource_deps.items():
            rid_file = resource_to_file.get(rid, "main")
            for dep in deps:
                dep_file = resource_to_file.get(dep, "main")
                if dep_file != rid_file:
                    file_deps[rid_file].add(dep_file)
                    edge = (rid_file, dep_file)
                    if edge not in cross_file_resources:
                        cross_file_resources[edge] = []
                    cross_file_resources[edge].append(rid)

        # Check for cycle
        cycle = _find_file_cycle(file_deps)
        if not cycle:
            break

        # Find the minimal set of resources to move to break the cycle
        # Look for edges within the cycle and move resources from the smaller side
        best_resources_to_move: list[str] = []
        best_count = float("inf")

        for i, file_a in enumerate(cycle):
            file_b = cycle[(i + 1) % len(cycle)]
            # Edge from file_a to file_b
            edge_ab = (file_a, file_b)
            resources_ab = cross_file_resources.get(edge_ab, [])

            # Moving these resources breaks the Aâ†’B edge
            if resources_ab and len(resources_ab) < best_count:
                best_count = len(resources_ab)
                best_resources_to_move = resources_ab

        if not best_resources_to_move:
            # Fallback: merge smallest file in cycle into main.py
            smallest_file = min(
                (f for f in cycle if f != "main" and f in separate_files),
                key=lambda f: len(separate_files.get(f, [])),
                default=None,
            )
            if smallest_file:
                for rid in separate_files[smallest_file]:
                    main_py_resources.append(rid)
                    resource_to_file[rid] = "main"
                del separate_files[smallest_file]
        else:
            # Move only the resources that create the cross-file edge
            for rid in best_resources_to_move:
                if resource_to_file.get(rid) == "main":
                    # Already in main, skip
                    continue
                old_file = resource_to_file.get(rid)
                if old_file and old_file in separate_files:
                    if rid in separate_files[old_file]:
                        separate_files[old_file].remove(rid)
                    if not separate_files[old_file]:
                        del separate_files[old_file]
                main_py_resources.append(rid)
                resource_to_file[rid] = "main"

    ctx.resource_to_file = resource_to_file

    # Now generate resource classes with file info available
    # Forward references within the same file are handled by placeholder support
    # in dataclass-dsl's two-pass loading
    resource_classes: dict[str, str] = {}
    resource_wrappers: dict[str, list[str]] = {}

    for resource_id in sorted_resources:
        resource = template.resources[resource_id]
        ctx.current_resource_file = resource_to_file.get(resource_id)

        wrapper_start_idx = len(ctx.property_type_class_defs)
        resource_class = generate_resource_class(resource, ctx)
        resource_classes[resource_id] = resource_class
        pkg_ctx.resources_exports.add(resource_id)
        resource_wrappers[resource_id] = ctx.property_type_class_defs[
            wrapper_start_idx:
        ]

    ctx.current_resource_file = None

    # Re-sort
    topo_order = {rid: idx for idx, rid in enumerate(sorted_resources)}
    main_py_resources.sort(key=lambda rid: topo_order[rid])
    for category in separate_files:
        separate_files[category].sort(key=lambda rid: topo_order[rid])

    # Generate main.py
    if main_py_resources:
        lines = []
        lines.append('"""Stack resources."""')
        lines.append("")
        lines.append("from . import *  # noqa: F403")
        lines.append("")
        lines.append("")

        # Interleave PropertyType wrappers with their resources
        # Order: wrappers for ResourceA, ResourceA, wrappers for ResourceB, ResourceB
        # This ensures wrappers can reference earlier resources with bare class names
        for res_id in main_py_resources:
            for pt_class_def in resource_wrappers.get(res_id, []):
                lines.append(pt_class_def)
                lines.append("")
                lines.append("")
            resource_class = resource_classes[res_id]
            lines.append(resource_class)
            lines.append("")
            lines.append("")

        while lines and lines[-1] == "":
            lines.pop()

        files["main.py"] = "\n".join(lines) + "\n"

    # Clear property_type_class_defs (no longer needed)
    ctx.property_type_class_defs.clear()

    # Generate category files
    for filename, resource_ids in separate_files.items():
        lines = []
        resource_names = ", ".join(resource_ids)
        lines.append(f'"""{filename.title()} resources: {resource_names}."""')
        lines.append("")
        lines.append("from . import *  # noqa: F403")
        lines.append("")
        lines.append("")

        # Interleave PropertyType wrappers with their resources
        for res_id in resource_ids:
            for pt_class_def in resource_wrappers.get(res_id, []):
                lines.append(pt_class_def)
                lines.append("")
                lines.append("")
            resource_class = resource_classes[res_id]
            lines.append(resource_class)
            lines.append("")
            lines.append("")

        while lines and lines[-1] == "":
            lines.pop()

        files[f"{filename}.py"] = "\n".join(lines) + "\n"

    return files

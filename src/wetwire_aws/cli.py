"""
CLI for wetwire-aws template generation.

Usage:
    wetwire-aws build [OPTIONS]
    wetwire-aws validate [OPTIONS]
    wetwire-aws list [OPTIONS]
    wetwire-aws import TEMPLATE [-o OUTPUT]
    wetwire-aws diff PATH --output FILE
    wetwire-aws watch PATH
    wetwire-aws --help

Examples:
    # Generate CloudFormation JSON to stdout
    wetwire-aws build --module myapp.infra > template.json

    # Generate with specific package scope
    wetwire-aws build --module myapp --scope myapp.infra

    # Generate YAML format
    wetwire-aws build --module myapp.infra --format yaml

    # Validate references without generating
    wetwire-aws validate --module myapp.infra

    # List registered resources
    wetwire-aws list --module myapp.infra

    # Import a CloudFormation template to Python
    wetwire-aws import template.yaml -o my_stack/

    # Compare generated output vs existing template
    wetwire-aws diff ./infra --output template.json

    # Watch for changes and rebuild
    wetwire-aws watch ./infra
"""

import argparse
import sys
from pathlib import Path
from typing import cast

from dataclass_dsl import LintIssue, create_lint_command

from wetwire_aws.cli_utils import (
    add_common_args,
    create_list_command,
    create_validate_command,
    discover_resources,
    error_exit,
    resolve_output_dir,
    validate_package_path,
)
from wetwire_aws.decorator import get_aws_registry
from wetwire_aws.linter import fix_file as _fix_file
from wetwire_aws.linter import lint_file as _lint_file
from wetwire_aws.stubs import AWS_STUB_CONFIG
from wetwire_aws.template import CloudFormationTemplate


# Wrapper functions to match the protocol signatures expected by create_lint_command
def lint_file(filepath: str) -> list[LintIssue]:
    """Wrapper matching LinterProtocol signature."""
    # Cast is needed because wetwire_aws.linter.LintIssue is a superset of dataclass_dsl.LintIssue
    return cast(list[LintIssue], _lint_file(filepath))


def fix_file(filepath: str, write: bool = True) -> str:
    """Wrapper matching FixerProtocol signature."""
    return _fix_file(filepath, write=write)


def get_cf_resource_type(cls: type) -> str:
    """
    Extract CloudFormation resource type from a wrapper class.

    Args:
        cls: The wrapper class decorated with @wetwire_aws

    Returns:
        The CloudFormation resource type string (e.g., "AWS::S3::Bucket")
    """
    annotations = getattr(cls, "__annotations__", {})
    resource_type_cls = annotations.get("resource")
    if resource_type_cls and hasattr(resource_type_cls, "_resource_type"):
        resource_type: str = resource_type_cls._resource_type
        return resource_type
    return "Unknown"


def init_command(args: argparse.Namespace) -> None:
    """Initialize a new wetwire-aws package."""
    output_dir = resolve_output_dir(args)
    package_name = args.name
    no_scaffold = getattr(args, "no_scaffold", False)

    # Validate package name
    if not package_name.replace("_", "").isalnum():
        error_exit(f"Invalid package name '{package_name}'. Use snake_case.")

    package_dir = output_dir / package_name

    if package_dir.exists() and not args.force:
        error_exit(
            f"Directory already exists: {package_dir}",
            hint="Use --force to overwrite.",
        )

    # Create package directory
    package_dir.mkdir(parents=True, exist_ok=True)

    # Create __init__.py with setup_params and setup_resources
    description = args.description or f"{package_name} infrastructure"
    init_content = f'''"""{description}

Generated by wetwire-aws init.
"""

from wetwire_aws.loader import setup_params, setup_resources

setup_params(globals())

from .params import *  # noqa: F403, F401

setup_resources(__file__, __name__, globals())

from .outputs import *  # noqa: F403, F401
'''
    (package_dir / "__init__.py").write_text(init_content)

    # Create params.py
    params_content = '''"""Parameters, Mappings, and Conditions."""

from . import *  # noqa: F403

# Define parameters here, e.g.:
# class BucketName(Parameter):
#     type = STRING
#     description = "Name of the S3 bucket"
#     default = "my-bucket"
'''
    (package_dir / "params.py").write_text(params_content)

    # Create outputs.py
    outputs_content = '''"""CloudFormation Outputs."""

from . import *  # noqa: F403

# Define outputs here, e.g.:
# class BucketArn(Output):
#     value = MyBucket.Arn
#     description = "ARN of the S3 bucket"
#     export_name = "my-bucket-arn"
'''
    (package_dir / "outputs.py").write_text(outputs_content)

    created_files = [
        f"{package_dir}/__init__.py",
        f"{package_dir}/params.py",
        f"{package_dir}/outputs.py",
    ]

    # Create scaffold files unless --no-scaffold
    if not no_scaffold:
        # Create README.md
        readme_content = f'''# {package_name}

AWS infrastructure defined with [wetwire-aws](https://github.com/lex00/wetwire-aws-python).

## Build

```bash
wetwire-aws build --module {package_name} > template.yaml
```

## Validate

```bash
wetwire-aws validate --module {package_name}
```

## Lint

```bash
wetwire-aws lint {package_name}/
```
'''
        (package_dir / "README.md").write_text(readme_content)
        created_files.append(f"{package_dir}/README.md")

        # Create CLAUDE.md
        claude_content = f'''# {package_name}

AWS CloudFormation infrastructure using wetwire-aws declarative Python syntax.

## Syntax

- Resources inherit from generated types: `class MyBucket(s3.Bucket):`
- Reference other resources directly: `bucket = MyBucket`
- Access attributes: `role = MyRole.Arn`
- Use typed constants: `runtime = lambda_.Runtime.PYTHON3_12`

## Build

```bash
wetwire-aws build --module {package_name}
```
'''
        (package_dir / "CLAUDE.md").write_text(claude_content)
        created_files.append(f"{package_dir}/CLAUDE.md")

        # Create .gitignore
        gitignore_content = '''# Python
__pycache__/
*.py[cod]
*$py.class
.Python
*.so

# wetwire-aws generated stubs
*.pyi

# IDE
.idea/
.vscode/
*.swp
*.swo

# Build outputs
*.yaml
*.json
!pyproject.toml
'''
        (package_dir / ".gitignore").write_text(gitignore_content)
        created_files.append(f"{package_dir}/.gitignore")

    print(f"Created package: {package_dir}")
    if args.verbose:
        for f in created_files:
            print(f"  {f}")


def import_command(args: argparse.Namespace) -> None:
    """Import a CloudFormation template and generate Python code."""
    from wetwire_aws.importer import import_template

    source = Path(args.template)
    if not source.exists():
        error_exit(f"Template file not found: {source}")

    # Determine output directory
    output_dir = resolve_output_dir(args)

    # Determine package name
    if args.name:
        package_name = args.name
    else:
        package_name = source.stem.replace("-", "_").replace(".", "_")

    # Generate code
    try:
        files = import_template(
            source,
            package_name=package_name,
            single_file=args.single_file,
        )
    except ValueError as e:
        error_exit(str(e))

    # Write files
    for filepath, content in files.items():
        full_path = output_dir / filepath
        full_path.parent.mkdir(parents=True, exist_ok=True)

        if full_path.exists() and not args.force:
            print(f"Skipping (exists): {full_path}", file=sys.stderr)
            continue

        full_path.write_text(content)
        if args.verbose:
            print(f"Created: {full_path}", file=sys.stderr)

    dest = output_dir / package_name
    print(f"Imported {len(files)} files to {dest}", file=sys.stderr)


def design_command(args: argparse.Namespace) -> None:
    """Run AI-assisted infrastructure design."""
    provider = getattr(args, "provider", "anthropic")
    output_dir = resolve_output_dir(args)
    prompt = args.prompt if args.prompt else None

    if provider == "kiro":
        # Use Kiro CLI provider
        try:
            from wetwire_aws.kiro import launch_kiro
        except ImportError:
            error_exit(
                "Kiro integration requires mcp package.",
                hint="Install with: pip install wetwire-aws[kiro]",
            )

        exit_code = launch_kiro(prompt=prompt, project_dir=output_dir)
        sys.exit(exit_code)
    else:
        # Use Anthropic API via wetwire-core
        try:
            from wetwire_core.agents import run_interactive_design
        except ImportError:
            error_exit(
                "wetwire-core required for design mode.",
                hint="Install with: pip install wetwire-core",
            )

        package_path, messages = run_interactive_design(
            initial_prompt=prompt,
            output_dir=output_dir,
        )

        if package_path:
            print(f"\nPackage created: {package_path}")
        else:
            print("\nNo package created.")


def test_command(args: argparse.Namespace) -> None:
    """Run automated persona-based testing."""
    provider = getattr(args, "provider", "anthropic")
    output_dir = resolve_output_dir(args)

    if provider == "kiro":
        # Use Kiro CLI provider
        try:
            from wetwire_aws.kiro import run_kiro_scenario
        except ImportError:
            error_exit(
                "Kiro integration requires mcp package.",
                hint="Install with: pip install wetwire-aws[kiro]",
            )

        print(f"Running Kiro scenario: {args.prompt}")
        print()

        result = run_kiro_scenario(
            prompt=args.prompt,
            project_dir=output_dir,
            timeout=getattr(args, "timeout", 300),
        )

        # Print results
        print("\n--- Scenario Results ---")
        print(f"Success: {result['success']}")
        print(f"Exit code: {result['exit_code']}")
        print(f"Package: {result['package_path'] or 'None'}")
        print(f"Template valid: {result['template_valid']}")

        if result["stdout"]:
            print("\n--- Stdout ---")
            print(result["stdout"][:2000])

        if result["stderr"]:
            print("\n--- Stderr ---")
            print(result["stderr"][:1000])

        sys.exit(0 if result["success"] else 1)
    else:
        # Use Anthropic API via wetwire-core
        try:
            from wetwire_core.agents import run_ai_scenario
        except ImportError:
            error_exit(
                "wetwire-core required for test mode.",
                hint="Install with: pip install wetwire-core",
            )

        # Persona definitions
        personas = {
            "beginner": "You are new to AWS. Ask clarifying questions about basic concepts.",
            "intermediate": "You have moderate AWS experience. Ask about best practices.",
            "expert": "You are an AWS expert. Ask about advanced configurations and edge cases.",
            "terse": "Give minimal, short responses. Just answer what's asked.",
            "verbose": "Provide detailed context and requirements in your responses.",
        }

        persona_name = args.persona
        if persona_name not in personas:
            error_exit(
                f"Unknown persona '{persona_name}'",
                hint=f"Available: {', '.join(personas.keys())}",
            )

        print(f"Running test with persona: {persona_name}")
        print(f"Prompt: {args.prompt}")
        print()

        package_path, messages = run_ai_scenario(
            prompt=args.prompt,
            persona_name=persona_name,
            persona_instructions=personas[persona_name],
            output_dir=output_dir,
        )

        # Print conversation summary
        print("\n--- Conversation Summary ---")
        for msg in messages:
            role = msg.role.upper()
            content = msg.content[:100] + "..." if len(msg.content) > 100 else msg.content
            print(f"[{role}] {content}")

        if package_path:
            print(f"\nPackage created: {package_path}")
        else:
            print("\nNo package created (test may have failed).")


def graph_command(args: argparse.Namespace) -> None:
    """Generate dependency graph from registered resources."""
    from wetwire_aws.graph import Graph

    registry = get_aws_registry()

    # Handle path argument (convert to module)
    if args.path:
        _, module_name = validate_package_path(args.path)
    elif args.module:
        module_name = args.module[0] if isinstance(args.module, list) else args.module
    else:
        error_exit("Either path or --module is required")

    # Discover resources
    discover_resources(module_name, registry, args.verbose)

    # Build graph
    graph = Graph.from_registry(
        registry,
        scope_package=args.scope,
        include_params=args.params,
    )

    # Output in requested format
    if args.format == "mermaid":
        print(graph.to_mermaid())
    else:
        print(graph.to_dot(cluster_by_service=args.cluster))


def diff_command(args: argparse.Namespace) -> None:
    """Compare generated output vs existing template."""
    import difflib
    import json

    registry = get_aws_registry()

    # Validate path
    if not Path(args.path).exists():
        error_exit(f"Path not found: {args.path}")

    _, module_name = validate_package_path(args.path)
    discover_resources(module_name, registry, args.verbose)

    # Check if any resources are registered
    resources = list(registry.get_all(None))
    if not resources:
        error_exit("No resources registered.")

    # Generate new template
    template = CloudFormationTemplate.from_registry(
        scope_package=None,
        description="",
    )
    new_output = template.to_json(indent=2)

    # Read existing template
    output_path = Path(args.output)
    if not output_path.exists():
        error_exit(f"Output file not found: {output_path}")

    existing_output = output_path.read_text()

    # Normalize trailing newlines
    new_output = new_output.rstrip() + "\n"
    existing_output = existing_output.rstrip() + "\n"

    # Semantic comparison: compare parsed JSON
    if args.semantic:
        try:
            new_json = json.loads(new_output)
            existing_json = json.loads(existing_output)
            if new_json == existing_json:
                print("No semantic differences.")
                return
            else:
                # Show structural differences
                print("Semantic differences detected.")
                # Pretty-print both and diff
                new_pretty = json.dumps(new_json, indent=2, sort_keys=True)
                existing_pretty = json.dumps(existing_json, indent=2, sort_keys=True)
                diff = difflib.unified_diff(
                    existing_pretty.splitlines(keepends=True),
                    new_pretty.splitlines(keepends=True),
                    fromfile=str(output_path),
                    tofile="(generated)",
                )
                sys.stdout.writelines(diff)
        except json.JSONDecodeError as e:
            error_exit(f"Invalid JSON: {e}")
    else:
        # Text comparison: line-by-line diff
        if new_output == existing_output:
            print("No diff.")
            return

        diff = difflib.unified_diff(
            existing_output.splitlines(keepends=True),
            new_output.splitlines(keepends=True),
            fromfile=str(output_path),
            tofile="(generated)",
        )
        sys.stdout.writelines(diff)


def watch_command(args: argparse.Namespace) -> None:
    """Watch for changes and auto-rebuild."""
    import time

    path = Path(args.path)
    if not path.exists():
        error_exit(f"Path not found: {path}")

    # Validate it's a package
    validate_package_path(str(path))

    print(f"Watching {path} for changes...")
    print("Press Ctrl+C to stop.")

    # Track file modification times
    def get_mtimes() -> dict[str, float]:
        mtimes = {}
        for py_file in path.rglob("*.py"):
            try:
                mtimes[str(py_file)] = py_file.stat().st_mtime
            except OSError:
                pass
        return mtimes

    last_mtimes = get_mtimes()
    debounce_time = 0.5  # seconds
    last_rebuild = 0.0

    try:
        while True:
            time.sleep(0.5)
            current_mtimes = get_mtimes()

            # Check for changes
            changed_files = []
            for filepath, mtime in current_mtimes.items():
                if filepath not in last_mtimes or last_mtimes[filepath] != mtime:
                    changed_files.append(filepath)

            if changed_files and (time.time() - last_rebuild) > debounce_time:
                print(f"\nChange detected: {', '.join(Path(f).name for f in changed_files)}")

                # Run lint if not --lint-only
                if args.lint_only:
                    # Just run lint
                    for filepath in changed_files:
                        issues = _lint_file(filepath)
                        if issues:
                            for issue in issues:
                                print(f"  {issue}")
                        else:
                            print(f"  {Path(filepath).name}: OK")
                else:
                    # Lint first
                    lint_passed = True
                    for filepath in changed_files:
                        issues = _lint_file(filepath)
                        if issues:
                            lint_passed = False
                            for issue in issues:
                                print(f"  {issue}")

                    if lint_passed:
                        # Rebuild
                        print("Rebuilding...")
                        try:
                            # Clear registry for fresh build
                            registry = get_aws_registry()
                            registry.clear()

                            _, module_name = validate_package_path(str(path))
                            discover_resources(module_name, registry, args.verbose)

                            template = CloudFormationTemplate.from_registry(
                                scope_package=None,
                                description="",
                            )
                            output = template.to_json(indent=2)

                            # Write to output file if specified
                            if args.output:
                                Path(args.output).write_text(output)
                                print(f"  Written to {args.output}")
                            else:
                                print(f"  Generated template with {len(template.resources)} resources")
                        except Exception as e:
                            print(f"  Build failed: {e}")
                    else:
                        print("  Lint errors, skipping build.")

                last_rebuild = time.time()
                last_mtimes = current_mtimes

    except KeyboardInterrupt:
        print("\nStopped watching.")


def build_command(args: argparse.Namespace) -> None:
    """Generate CloudFormation template from registered resources."""
    registry = get_aws_registry()

    # Handle path argument (convert to module)
    if args.path:
        _, module_name = validate_package_path(args.path)
        discover_resources(module_name, registry, args.verbose)
    # Import modules to discover resources
    elif args.modules:
        for module_path in args.modules:
            discover_resources(module_path, registry, args.verbose)

    # Check if any resources are registered
    resources = list(registry.get_all(args.scope))
    if not resources:
        if args.scope:
            error_exit(f"No resources found in scope '{args.scope}'")
        else:
            error_exit(
                "No resources registered.",
                hint="Import your resource modules with --module, e.g.: wetwire-aws build --module myapp.infra",
            )

    # Generate template
    template = CloudFormationTemplate.from_registry(
        scope_package=args.scope,
        description=args.description or "",
    )

    # Output in requested format
    if args.format == "yaml":
        try:
            output = template.to_yaml()
        except ImportError:
            error_exit(
                "PyYAML required for YAML output.",
                hint="Install with: pip install pyyaml",
            )
    else:
        output = template.to_json(indent=args.indent)

    print(output)

    if args.verbose:
        print(
            f"\nGenerated template with {len(template.resources)} resources",
            file=sys.stderr,
        )


def main() -> None:
    """Main CLI entry point."""
    registry = get_aws_registry()

    parser = argparse.ArgumentParser(
        prog="wetwire-aws",
        description="Generate CloudFormation templates from wetwire-aws resources",
    )
    from importlib.metadata import version as get_version

    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {get_version('wetwire-aws')}",
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Init command
    init_parser = subparsers.add_parser(
        "init",
        help="Initialize a new wetwire-aws package",
    )
    init_parser.add_argument(
        "name",
        help="Package name (snake_case, e.g., 'my_app')",
    )
    init_parser.add_argument(
        "--output",
        "-o",
        help="Output directory (default: current directory)",
    )
    init_parser.add_argument(
        "--description",
        "-d",
        help="Package description",
    )
    init_parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Overwrite existing directory",
    )
    init_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Verbose output",
    )
    init_parser.add_argument(
        "--no-scaffold",
        action="store_true",
        help="Skip README.md, CLAUDE.md, and .gitignore",
    )
    init_parser.set_defaults(func=init_command)

    # Build command (AWS-specific)
    build_parser = subparsers.add_parser(
        "build",
        help="Generate CloudFormation template",
    )
    build_parser.add_argument(
        "path",
        nargs="?",
        help="Path to package directory (alternative to --module)",
    )
    add_common_args(build_parser)
    build_parser.add_argument(
        "--format",
        "-f",
        choices=["json", "yaml"],
        default="json",
        help="Output format (default: json)",
    )
    build_parser.add_argument(
        "--indent",
        "-i",
        type=int,
        default=2,
        help="JSON indentation (default: 2)",
    )
    build_parser.add_argument(
        "--description",
        "-d",
        help="Template description",
    )
    build_parser.set_defaults(func=build_command)

    # Validate command (uses base implementation)
    validate_parser = subparsers.add_parser(
        "validate",
        help="Validate resources and references",
    )
    add_common_args(validate_parser)
    validate_parser.set_defaults(func=create_validate_command(registry))

    # List command (uses base implementation)
    list_parser = subparsers.add_parser(
        "list",
        help="List registered resources",
    )
    add_common_args(list_parser)
    list_parser.set_defaults(func=create_list_command(registry, get_cf_resource_type))

    # Import command
    import_parser = subparsers.add_parser(
        "import",
        help="Import CloudFormation template to Python code",
    )
    import_parser.add_argument(
        "template",
        help="Path to CloudFormation template (YAML or JSON)",
    )
    import_parser.add_argument(
        "--output",
        "-o",
        help="Output directory (default: current directory)",
    )
    import_parser.add_argument(
        "--name",
        "-n",
        help="Package name (default: derived from template filename)",
    )
    import_parser.add_argument(
        "--single-file",
        action="store_true",
        help="Generate a single Python file instead of a package",
    )
    import_parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Overwrite existing files",
    )
    import_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Verbose output",
    )
    import_parser.set_defaults(func=import_command)

    # Lint command
    lint_parser = subparsers.add_parser(
        "lint",
        help="Lint wetwire-aws code for issues",
    )
    lint_parser.add_argument(
        "path",
        help="Path to Python file or directory to lint",
    )
    lint_parser.add_argument(
        "--fix",
        action="store_true",
        help="Auto-fix detected issues",
    )
    lint_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Verbose output",
    )
    lint_parser.set_defaults(
        func=create_lint_command(lint_file, fix_file, AWS_STUB_CONFIG)
    )

    # Graph command
    graph_parser = subparsers.add_parser(
        "graph",
        help="Generate dependency graph in DOT or Mermaid format",
    )
    graph_parser.add_argument(
        "path",
        nargs="?",
        help="Path to package directory (alternative to --module)",
    )
    add_common_args(graph_parser)
    graph_parser.add_argument(
        "--format",
        "-f",
        choices=["dot", "mermaid"],
        default="dot",
        help="Output format (default: dot)",
    )
    graph_parser.add_argument(
        "--params",
        "-p",
        action="store_true",
        help="Include parameter nodes in graph",
    )
    graph_parser.add_argument(
        "--cluster",
        "-c",
        action="store_true",
        help="Cluster nodes by AWS service",
    )
    graph_parser.set_defaults(func=graph_command)

    # Diff command
    diff_parser = subparsers.add_parser(
        "diff",
        help="Compare generated output vs existing template",
    )
    diff_parser.add_argument(
        "path",
        help="Path to package directory",
    )
    diff_parser.add_argument(
        "--output",
        "-o",
        required=True,
        help="Path to existing template file to compare against",
    )
    diff_parser.add_argument(
        "--semantic",
        "-s",
        action="store_true",
        help="Use semantic comparison (ignore formatting)",
    )
    diff_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Verbose output",
    )
    diff_parser.set_defaults(func=diff_command)

    # Watch command
    watch_parser = subparsers.add_parser(
        "watch",
        help="Watch for changes and auto-rebuild",
    )
    watch_parser.add_argument(
        "path",
        help="Path to package directory to watch",
    )
    watch_parser.add_argument(
        "--output",
        "-o",
        help="Output file to write template to",
    )
    watch_parser.add_argument(
        "--lint-only",
        action="store_true",
        help="Only run lint, skip rebuild",
    )
    watch_parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Verbose output",
    )
    watch_parser.set_defaults(func=watch_command)

    # Design command (AI-assisted)
    design_parser = subparsers.add_parser(
        "design",
        help="AI-assisted infrastructure design",
    )
    design_parser.add_argument(
        "prompt",
        nargs="?",
        help="Initial prompt describing what to build (interactive if omitted)",
    )
    design_parser.add_argument(
        "--output",
        "-o",
        help="Output directory (default: current directory)",
    )
    design_parser.add_argument(
        "--provider",
        "-p",
        choices=["anthropic", "kiro"],
        default="anthropic",
        help="AI provider to use (default: anthropic)",
    )
    design_parser.set_defaults(func=design_command)

    # Test command (automated testing with personas)
    test_parser = subparsers.add_parser(
        "test",
        help="Run automated scenario testing",
    )
    test_parser.add_argument(
        "prompt",
        help="Infrastructure description to test",
    )
    test_parser.add_argument(
        "--persona",
        default="intermediate",
        help="Persona to use (anthropic only): beginner, intermediate, expert, terse, verbose",
    )
    test_parser.add_argument(
        "--output",
        "-o",
        help="Output directory (default: current directory)",
    )
    test_parser.add_argument(
        "--provider",
        "-p",
        choices=["anthropic", "kiro"],
        default="anthropic",
        help="AI provider to use (default: anthropic)",
    )
    test_parser.add_argument(
        "--timeout",
        "-t",
        type=int,
        default=300,
        help="Timeout in seconds for kiro provider (default: 300)",
    )
    test_parser.set_defaults(func=test_command)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    args.func(args)


if __name__ == "__main__":
    main()
